<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="CanisterSigs.html">CanisterSigs</a></li></li><li><li><a href="CertTree.html">CertTree</a></li></li><li><li><a href="Dyadic.html">Dyadic</a></li></li><li><li><a href="MerkleTree.html">MerkleTree</a></li></li><li><li><a href="ReqData.html">ReqData</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.PublicKey">PublicKey</a></li></li><li><li><a href="#type.Seed">Seed</a></li></li><li><li><a href="#type.Signature">Signature</a></li></li><li><li><a href="#type.PayloadHash">PayloadHash</a></li></li><li><li><a href="#publicKey">publicKey</a></li></li><li><li><a href="#selfAuthenticatingPrincipal">selfAuthenticatingPrincipal</a></li></li><li><li><a href="#signature">signature</a></li></li><li><li><a href="#type.Manager">Manager</a></li></li></ul></nav><div class="documentation"><h1>CanisterSigs</h1><p><strong>Internet Computer Canister Signatures</strong></p>
<p>This modules allows canister to produce signatures according to the
“<a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#canister-signatures">Canister Signature scheme</a>”.</p>
<div class="declaration"><h4 class="type-declaration" id="type.PublicKey"><span class="keyword">type </span><span class="type">PublicKey</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Seed"><span class="keyword">type </span><span class="type">Seed</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Signature"><span class="keyword">type </span><span class="type">Signature</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.PayloadHash"><span class="keyword">type </span><span class="type">PayloadHash</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="function" id="publicKey"><code><span class="keyword">public func </span><span class="fnname">publicKey</span>(<span class="parameter">canister_id</span> : <span class="type">Principal</span>, <span class="parameter">seed</span> : <a href="#type.Seed"><span class="type">Seed</span></a>) : <a href="#type.PublicKey"><span class="type">PublicKey</span></a></code></h4><p><p>Calculate the DER-encoded public key for the given canister and seed</p>
</p></div><div class="declaration"><h4 class="function" id="selfAuthenticatingPrincipal"><code><span class="keyword">public func </span><span class="fnname">selfAuthenticatingPrincipal</span>(<span class="parameter">publicKey</span> : <a href="#type.PublicKey"><span class="type">PublicKey</span></a>) : <span class="type">Principal</span></code></h4><p><p>Derive a self-authenticating principal from a public key</p>
</p></div><div class="declaration"><h4 class="function" id="signature"><code><span class="keyword">public func </span><span class="fnname">signature</span>(<span class="parameter">cert</span> : <span class="type">Blob</span>, <span class="parameter">witness</span> : <a href="MerkleTree.html#type.Witness"><span class="type">MerkleTree.Witness</span></a>) : <a href="#type.Signature"><span class="type">Signature</span></a></code></h4><p><p>Encode the system certificate and the canister's hash tree witness
as a Canister Signature scheme signature (CBOR-encoded)</p>
<p>The witness must reveal the path <code>[&quot;sigs&quot;,seed, hash_of_msg_payload]</code>.
So for example in an update method run something like</p>
<pre><code>let sig_payload_hash = h2(&quot;\0Aic-request&quot;, request_id);
let path : CertTree.Path = [&quot;sig&quot;, h &quot;&quot;, sig_payload_hash];
ct.put(path, &quot;&quot;);
ct.setCertifiedData();</code></pre><p>and then in the query method obtain the witness and the signature using</p>
<pre><code>let witness = ct.reveal(req_data.path);
let sig = CanisterSigs.signature(cert, witness);</code></pre></p></div><div class="declaration"><h4 class="class-declaration" id="type.Manager"><span class="keyword">class </span><span class="classname">Manager</span>(<span class="parameter">ct</span> : <a href="CertTree.html#type.Ops"><span class="type">CertTree.Ops</span></a>, <span class="parameter">expiry</span> : ?<span class="type">Time.Time</span>)</h4><div class="declaration"><h4 class="function" id="Manager.prepare"><code><span class="keyword">public func </span><span class="fnname">prepare</span>(<span class="parameter">seed</span> : <a href="#type.Seed"><span class="type">Seed</span></a>, <span class="parameter">plh</span> : <a href="#type.PayloadHash"><span class="type">PayloadHash</span></a>)</code></h4><p><p>Prepare a signature.</p>
<p>The second argument is the hashed paylaod, e.g.</p>
<pre><code>let request_id = ReqData.hash(content);
let sig_payload_hash = h2(&quot;\0Aic-request&quot;, request_id);
csm.prepare(&quot;&quot;, sig_payload_hash);</code></pre>

<p>Also calls <code>setCertifiedData()</code> on the certified data for you.</p>
</p></div><div class="declaration"><h4 class="function" id="Manager.fetch"><code><span class="keyword">public func </span><span class="fnname">fetch</span>(<span class="parameter">seed</span> : <a href="#type.Seed"><span class="type">Seed</span></a>, <span class="parameter">plh</span> : <a href="#type.PayloadHash"><span class="type">PayloadHash</span></a>) : <a href="#type.Signature"><span class="type">Signature</span></a></code></h4><p><p>Generate the signature.</p>
<p>This only works in a query <em>call</em>, and will trap if no certificate is available.</p>
</p></div><div class="declaration"><h4 class="function" id="Manager.prune"><code><span class="keyword">public func </span><span class="fnname">prune</span>()</code></h4><p><p>Drops expired signatures from the state tree.
This is automatically called from <code>prepare</code>, so usually
you do not need to call this.</p>
</p></div><div class="declaration"><h4 class="function" id="Manager.pruneAll"><code><span class="keyword">public func </span><span class="fnname">pruneAll</span>()</code></h4><p><p>Drops all signatures. Useful in the pre_upgrade hook, to keep things tidy
else signatures may lurk there forever, if the CanisterSigManager forgets about them.</p>
</p></div><div class="declaration"><h4 class="function" id="Manager.size"><code><span class="keyword">public func </span><span class="fnname">size</span>() : <span class="type">Nat</span></code></h4><p><p>Number of unexpired signatures. Useful to inculde in metrics</p>
</p></div><p><p>The canister signature manager class provides a bit of convenience for keeping track of the
prepare/fetch/delete cycle.</p>
<p>Instantiate it with access to your canister's <code>CertTree.Ops</code>, e.g.</p>
<pre><code>stable let cert_store : CertTree.Store = CertTree.newStore();
let ct = CertTree.Ops(cert_store);
let csm = CanisterSigs.Manager(ct, null); </code></pre><p>Then in the update call, call <code>prepare</code>, and in the query call call <code>fetch</code>.</p>
<p>If your <code>CertTree.Store</code> is stable, it is recommended to prune all signatures in pre or
post-upgrade:</p>
<pre><code>system func preupgrade() {
 csm.pruneAll();
};</code></pre></p></div></div></body></html>