<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="CanisterSigs.html">CanisterSigs</a></li></li><li><li><a href="CertTree.html">CertTree</a></li></li><li><li><a href="Dyadic.html">Dyadic</a></li></li><li><li><a href="MerkleTree.html">MerkleTree</a></li></li><li><li><a href="ReqData.html">ReqData</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Store">Store</a></li></li><li><li><a href="#type.Path">Path</a></li></li><li><li><a href="#type.Value">Value</a></li></li><li><li><a href="#type.Key">Key</a></li></li><li><li><a href="#type.Hash">Hash</a></li></li><li><li><a href="#type.Witness">Witness</a></li></li><li><li><a href="#newStore">newStore</a></li></li><li><li><a href="#type.Ops">Ops</a></li></li></ul></nav><div class="documentation"><h1>CertTree</h1><p><strong>Imperative wrapper of MerkleTree</strong></p>
<p>This module contains an imperative wrapper of the functional API provided by <code>MerkleTree</code>.
This makes common usage pattern around these trees more convenient.</p>
<p>This module defines two types:</p>
<ul><li><p>The <code>Store</code>. This is meant to be your canister's single hash tree. It is separated
 from the class providing functions so that it can be put in stable memory:</p>
</li><li><p>The <code>Ops</code> class. This wraps such a <code>Store</code> and offers all the operations you expect.</p>
</li></ul>

<p>So this is the suggested idiom:</p>
<pre><code>  stable let cert_store : CertTree.Store = CertTree.newStore();
  let ct = CertTree.Ops(cert_store);
  </code></pre><div class="declaration"><h4 class="type-declaration" id="type.Store"><span class="keyword">type </span><span class="type">Store</span> = { <span class="keyword">var </span>tree : <a href="MerkleTree.html#type.Tree"><span class="type">MerkleTree.Tree</span></a> }</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Path"><span class="keyword">type </span><span class="type">Path</span> = <a href="MerkleTree.html#type.Path"><span class="type">MerkleTree.Path</span></a></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Value"><span class="keyword">type </span><span class="type">Value</span> = <a href="MerkleTree.html#type.Value"><span class="type">MerkleTree.Value</span></a></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Key"><span class="keyword">type </span><span class="type">Key</span> = <a href="MerkleTree.html#type.Key"><span class="type">MerkleTree.Key</span></a></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Hash"><span class="keyword">type </span><span class="type">Hash</span> = <a href="MerkleTree.html#type.Hash"><span class="type">MerkleTree.Hash</span></a></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Witness"><span class="keyword">type </span><span class="type">Witness</span> = <a href="MerkleTree.html#type.Witness"><span class="type">MerkleTree.Witness</span></a></h4><p></p></div><div class="declaration"><h4 class="function" id="newStore"><code><span class="keyword">public func </span><span class="fnname">newStore</span>() : <a href="#type.Store"><span class="type">Store</span></a></code></h4><p></p></div><div class="declaration"><h4 class="class-declaration" id="type.Ops"><span class="keyword">class </span><span class="classname">Ops</span>(<span class="parameter">ct</span> : <a href="#type.Store"><span class="type">Store</span></a>)</h4><div class="declaration"><h4 class="function" id="Ops.put"><code><span class="keyword">public func </span><span class="fnname">put</span>(<span class="parameter">ks</span> : <a href="#type.Path"><span class="type">Path</span></a>, <span class="parameter">v</span> : <a href="#type.Value"><span class="type">Value</span></a>)</code></h4><p><p>Inserting a value at a given path into the tree.</p>
<p>An existing value (or subtree) under that path is overridden.</p>
<p>If there are values at any prefix of the given path,
they will be removed.</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>(<span class="parameter">ks</span> : <a href="#type.Path"><span class="type">Path</span></a>)</code></h4><p><p>Deleting a path from a tree.</p>
<p>This removes the given path from the tree, independently
of whether there is a value at that path, or a whole subtree.</p>
<p>If there are values at any prefix of the given path,
they will be removed.</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.lookup"><code><span class="keyword">public func </span><span class="fnname">lookup</span>(<span class="parameter">ks</span> : <a href="#type.Path"><span class="type">Path</span></a>) : ?<a href="#type.Value"><span class="type">Value</span></a></code></h4><p><p>Looking up a value at a path</p>
<p>This will return <code>null</code> if the path does not exist, or if 
there is a subtree (and not a value) at that key.</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.labelsAt"><code><span class="keyword">public func </span><span class="fnname">labelsAt</span>(<span class="parameter">ks</span> : <a href="#type.Path"><span class="type">Path</span></a>) : <span class="type">Iter.Iter</span>&lt;<a href="#type.Key"><span class="type">Key</span></a>&gt;</code></h4><p><p>Lookup up all labels at a path.</p>
<p>Returns an iterator, so you can use it with</p>
<pre><code>for (k in ct.labelsAt([&quot;some&quot;, &quot;path&quot;))) { â€¦ }</code></pre></p></div><div class="declaration"><h4 class="function" id="Ops.treeHash"><code><span class="keyword">public func </span><span class="fnname">treeHash</span>() : <a href="#type.Hash"><span class="type">Hash</span></a></code></h4><p><p>Root hash</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.setCertifiedData"><code><span class="keyword">public func </span><span class="fnname">setCertifiedData</span>()</code></h4><p><p>Sets the canister's certified data to the root hash
Call this at the end of any update function that changed the certified data tree</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.reveal"><code><span class="keyword">public func </span><span class="fnname">reveal</span>(<span class="parameter">path</span> : <a href="#type.Path"><span class="type">Path</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Create a witness that reveals the value of the key <code>k</code> in the tree <code>tree</code>.</p>
<p>If <code>k</code> is not in the tree, the witness will prove that fact.</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.reveals"><code><span class="keyword">public func </span><span class="fnname">reveals</span>(<span class="parameter">paths</span> : <span class="type">Iter.Iter</span>&lt;<a href="#type.Path"><span class="type">Path</span></a>&gt;) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Reveals multiple paths</p>
</p></div><div class="declaration"><h4 class="function" id="Ops.encodeWitness"><code><span class="keyword">public func </span><span class="fnname">encodeWitness</span>(<span class="parameter">w</span> : <a href="#type.Witness"><span class="type">Witness</span></a>) : <span class="type">Blob</span></code></h4><p><p>Encodes a witness as CBOR, e.g. for certified assets</p>
</p></div><p></p></div></div></body></html>