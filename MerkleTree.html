<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Dyadic.html">Dyadic</a></li></li><li><li><a href="MerkleTree.html">MerkleTree</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Key">Key</a></li></li><li><li><a href="#type.Path">Path</a></li></li><li><li><a href="#type.Value">Value</a></li></li><li><li><a href="#type.Tree">Tree</a></li></li><li><li><a href="#type.Witness">Witness</a></li></li><li><li><a href="#type.Hash">Hash</a></li></li><li><li><a href="#treeHash">treeHash</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#delete">delete</a></li></li><li><li><a href="#reveal">reveal</a></li></li><li><li><a href="#merge">merge</a></li></li><li><li><a href="#revealNothing">revealNothing</a></li></li><li><li><a href="#reveals">reveals</a></li></li><li><li><a href="#reconstruct">reconstruct</a></li></li><li><li><a href="#type.RawTree">RawTree</a></li></li><li><li><a href="#structure">structure</a></li></li><li><li><a href="#encodeWitness">encodeWitness</a></li></li></ul></nav><div class="documentation"><h1>MerkleTree</h1><p><strong>A merkle tree</strong></p>
<p>This library provides a simple merkle tree data structure for Motoko.
It provides a key-value store, where both keys and values are of type Blob.</p>
<pre class="motoko"><code class="motoko">var t = MerkleTree.empty();
t := MerkleTree.put(t, &quot;Alice&quot;, &quot;\00\01&quot;);
t := MerkleTree.put(t, &quot;Bob&quot;, &quot;\00\02&quot;);

let w = MerkleTree.reveals(t, [&quot;Alice&quot; : Blob, &quot;Malfoy&quot;: Blob].vals());</code></pre><p>will produce</p>
<pre><code>#fork (#labeled (&quot;\3B…\43&quot;, #leaf(&quot;\00\01&quot;)), #pruned (&quot;\EB…\87&quot;))
#fork(#labeled(&quot;\41\6C\69\63\65&quot;, #leaf(&quot;\00\01&quot;)), #labeled(&quot;\42\6F\62&quot;, #pruned(&quot;\E6…\E2&quot;)))</code></pre>

<p>The witness format is compatible with
the <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec#certificate">HashTree</a> used by the Internet Computer,
so client-side, the same logic can be used, but note</p>
<ul><li>no CBOR encoding is provided here. The assumption is that the witnesses are transferred
 via Candid, and decoded to a data type understood by the client-side library.</li></ul>

<p>Revealing multiple keys at once is supported, and so is proving absence of a key.</p>
<p>The tree branches on the bits of the keys (i.e. a patricia tree). This means that the merkle
tree and thus the root hash is unique for a given tree. This in particular means that insertions
are efficient, and that the tree can be reconstructed from the data, independently of the
insertion order.</p>
<p>A functional API is provided (instead of an object-oriented one), so that
the actual tree can easily be stored in stable memory.</p>
<p>The tree-related functions are still limited, only insertion so far, no
lookup, deletion, modification, or more fancy operations. These can be added
when needed.</p>
<div class="declaration"><h4 class="type-declaration" id="type.Key"><span class="keyword">type </span><span class="type">Key</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Path"><span class="keyword">type </span><span class="type">Path</span> = [<span class="type">Blob</span>]</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Value"><span class="keyword">type </span><span class="type">Value</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Tree"><span class="keyword">type </span><span class="type">Tree</span> = <a href="#type.LabeledTree"><span class="type">LabeledTree</span></a></h4><p><p>This is the main type of this module: a possibly empty tree that maps
<code>Key</code>s to <code>Value</code>s.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Witness"><span class="keyword">type </span><span class="type">Witness</span> = {#empty; #pruned : <a href="#type.Hash"><span class="type">Hash</span></a>; #fork : (<a href="#type.Witness"><span class="type">Witness</span></a>, <a href="#type.Witness"><span class="type">Witness</span></a>); #labeled : (<a href="#type.Key"><span class="type">Key</span></a>, <a href="#type.Witness"><span class="type">Witness</span></a>); #leaf : <a href="#type.Value"><span class="type">Value</span></a>}</h4><p><p>The type of witnesses. This correponds to the <code>HashTree</code> in the Interface
Specification of the Internet Computer</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Hash"><span class="keyword">type </span><span class="type">Hash</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="function" id="treeHash"><code><span class="keyword">public func </span><span class="fnname">treeHash</span>(<span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>) : <a href="#type.Hash"><span class="type">Hash</span></a></code></h4><p><p>The root hash of the merkle tree. This is the value that you would sign
or pass to <code>CertifiedData.set</code></p>
</p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>() : <a href="#type.Tree"><span class="type">Tree</span></a></code></h4><p><p>Tree construction: The empty tree</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>(<br/>  <span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <br/>  <span class="parameter">ks</span> : <a href="#type.Path"><span class="type">Path</span></a>, <br/>  <span class="parameter">v</span> : <a href="#type.Value"><span class="type">Value</span></a><br/>) : <a href="#type.Tree"><span class="type">Tree</span></a></code></h4><p><p>Tree construction: Inserting a key into the tree.
An existing value under that key is overridden.
This also deletes all keys at all paths that are a
prefix of the given path!</p>
</p></div><div class="declaration"><h4 class="function" id="delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>(<span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <span class="parameter">ks</span> : <a href="#type.Path"><span class="type">Path</span></a>) : <a href="#type.Tree"><span class="type">Tree</span></a></code></h4><p><p>Deleting a key from a tree.
This removes the given key from the tree, independently
of whether there is a value at that label, or a whole subtree.
Will also remove enclosing labels if there is no value left.</p>
</p></div><div class="declaration"><h4 class="function" id="reveal"><code><span class="keyword">public func </span><span class="fnname">reveal</span>(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <span class="parameter">path</span> : <a href="#type.Path"><span class="type">Path</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Create a witness that reveals the value of the key <code>k</code> in the tree <code>tree</code>.</p>
<p>If <code>k</code> is not in the tree, the witness will prove that fact.</p>
</p></div><div class="declaration"><h4 class="function" id="merge"><code><span class="keyword">public func </span><span class="fnname">merge</span>(<span class="parameter">w1</span> : <a href="#type.Witness"><span class="type">Witness</span></a>, <span class="parameter">w2</span> : <a href="#type.Witness"><span class="type">Witness</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Merges two witnesses, to reveal multiple values.</p>
<p>The two witnesses must come from the same tree, else this function is
undefined (and may trap).</p>
</p></div><div class="declaration"><h4 class="function" id="revealNothing"><code><span class="keyword">public func </span><span class="fnname">revealNothing</span>(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Reveal nothing from the tree. Mostly useful as a netural element to <code>merge</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="reveals"><code><span class="keyword">public func </span><span class="fnname">reveals</span>(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <span class="parameter">ks</span> : <span class="type">Iter.Iter</span>&lt;<a href="#type.Path"><span class="type">Path</span></a>&gt;) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Reveals multiple paths</p>
</p></div><div class="declaration"><h4 class="function" id="reconstruct"><code><span class="keyword">public func </span><span class="fnname">reconstruct</span>(<span class="parameter">w</span> : <a href="#type.Witness"><span class="type">Witness</span></a>) : <a href="#type.Hash"><span class="type">Hash</span></a></code></h4><p><p>We can reconstruct the root witness from a witness</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.RawTree"><span class="keyword">type </span><span class="type">RawTree</span> = {#value : <span class="type">Blob</span>; #subtree : [(<a href="#type.Key"><span class="type">Key</span></a>, <a href="#type.RawTree"><span class="type">RawTree</span></a>)]}</h4><p><p>The return type of <code>structure</code></p>
</p></div><div class="declaration"><h4 class="function" id="structure"><code><span class="keyword">public func </span><span class="fnname">structure</span>(<span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>) : <a href="#type.RawTree"><span class="type">RawTree</span></a></code></h4><p><p>Extract the raw data from the trees, mostly for pretty-printing</p>
</p></div><div class="declaration"><h4 class="function" id="encodeWitness"><code><span class="keyword">public func </span><span class="fnname">encodeWitness</span>(<span class="parameter">tree</span> : <a href="#type.Witness"><span class="type">Witness</span></a>) : <span class="type">Blob</span></code></h4><p><p>The CBOR encoding of a Witness, according to
<a href="https://sdk.dfinity.org/docs/interface-spec/index.html#certification-encoding">https://sdk.dfinity.org/docs/interface-spec/index.html#certification-encoding</a>
including the CBOR self-describing tag</p>
</p></div></div></body></html>